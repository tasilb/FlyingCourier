<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Flying Courier</title>
<style>

  body {
    background-color: #99ffff
    font-family: Serif;
    margin: auto;
    padding: 100px;
    padding-top: 30px;
    padding-bottom: 30px;
  }

  .center{
    text-align: center;
  }


</style>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


</head>

<body>
<h1>Flying Courier</h1>
<p>Final project of EE 106A, as instructed by Prof. R. Bajcsy</p>
<p>Implemented by David Tsai, Alex Kashi, Lucy Chen, Vanessa Salas</p>

<h3>Introduction</h3>
<p>Our goal was to design an autonomous quadrotor system to deliver a parcel to a specified destination. Using MAVROS, our quadcopter would seek and navigate to a user-defined sequence of waypoints. Because our system is intended for use in various indoor layouts, we are faced with the challenge of designing a system that localizes and navigates with limited modifications to the environment. Such a system could potentially be adapted for use in applications such as last-mile autonomous delivery, as well as extended-range manipulation and streamlined localization.</p>

<h3>Design</h3>
<h4>Quadcopter</h4>
<p>We wanted our robot to support both a powerful onboard computer, as well as a large payload. Modifying a ready-to-fly quadcopter would not be a wise investment, as modifications are usually unsupported and may have compatibility issues. We decided to go with a custom quadcopter build in a "+" configuration (one motor on each side, one in front, one in back), with motors, propellors, and batteries specced to support approximately 2.5 kilograms fully assembled and loaded.</p>
<p>We also wanted our electrical system to be compact and reduce wire clutter. To make the design a little simpler on our end, we included a power distribution board intended to supply regulated power. This introduced a few wires, but provided some accessibility for maintaining some electrical components.</p>
<p>For a quick proof of concept, a less powerful design may have been a better choice. Prototyping with as much power as we did was a liability for little tangible benefit. However, because our goal was a full implementation on a limited budget, we decided that the risk was acceptable.</p>

<h4>Software</h4>
<p>Because an additional source of positioning information such as GPS, optical flow, or motion capture were not readily available to us, we also required that we have some way of localizing our robot that was software-oriented. For this, we designed our own motion capture system that works with the parts we already have. We based the system around an array of AR tags, for which there already exists a technique for extracting relative pose information. We combined it with our knowledge of rigid body
transformations to produce a solution that is robust to a degree of occlusion and, to an extent, distance from the tags. We also required that our system operate with modal behavior according to a state machine. We also needed it to be easy to analyze and debug. Given these requirements, we used a mediator-style architecture in ROS. In our design, a base node publishes the status of the system with respect to its modal behavior, and each subcomponent node is responsible for taking actions to enforce the conditions of the particular state reported by the base node.</p>
<p>As an example, if the safety monitor detects a position violation, it will request that the main status is changed to the fault state. As the setpoint manager sees the fault state, it will stop publishing setpoints to MAVROS. As the flight mode manager sees the fault state, it will continually attempt to set the flight mode in MAVROS to the specified failsafe mode.</p>
<p>With this structure, subcomponents are able to operate independently of other subcomponents and simplify the execution model, as opposed to a monolithic timed loop that attempts to encompass all of the system's functionality. By changing the main status, the base node is able to indirectly control the system. This cost of this approach is an increase in verbosity and complexity, but it provides valuable composability and maintainability.</p>

<h3>Implementation</h3>
<h4>Quadcopter</h4>
<p>For the quadcopter, our list of components includes a set of 920KV motors, propellors, four-cell lithium polymer batteries, a carbon fiber frame, a power distribution board, and the Pixhawk flight control unit (FCU). On the computational side, we used an Intel Joule single-board computer (SBC), a powered USB hub, a USB webcam, and a metal gear servo. The hub connected the FCU and camera to the SBC. Our system is connected as in the following diagram:</p>

<div class=row>
  <div class="img-responsive">
    <img class=center-block src="hardware_schematic.png" alt="">
  </div>
</div>
<br><br>

<h4>Localization</h4>
<p>The next component we implemented was our localization array. We printed out 100 19.5 cm AR tags and backed them together in a 10 by 10 grid with foamboard and specified one to be the origin tag. By measuring the distance between centers of tags, we computed the rigid body transformation \(g_{ot}\) between each tag and the origin tag. In our code, we cached these inter-array transformations, knowing that they were intended to be static. Another static item we cached was the transformation between the
webcam's frame of reference and the FCU's frame of reference, \(g_{cf}\), as defined by a tf broadcaster we wrote to spatially represent our airframe in ROS. Then, to calculate the position of the robot relative to the origin tag (assuming the camera detects the tag), is \(g_{ot} g_{ct}^{-1} g_{cf}\), where \(g_{ct}\) is the transformation from the tag to the camera, as reported by, ar_track_alvar, the tag tracking ROS package we are using.<p>
<p>To improve the robustness of this system, we implemented a simple averaging step over all the tag transformations within a short period of time. By doing this, we mitigate the effects of outliers due to ar_track_alvar errors and prevent the system from failing if some of the tags within the camera's view are occluded. To implement this, we introduced two lists to simplify bookkeeping. Each list is 100 elements, with each index corresponding to a tag on our grid. One list contains
the timestamp of the last time a tag was seen, and another contains the transformation from the FCU to the origin corresponding to that time. On every tf message, we lock our lists with a mutex, update the lists with timestamps and transformations, and then unlock it. Our localization loop, running at 10 Hz by default, acquires the lock and filters the timestamp list for indices that have been updated within the last 0.2 seconds. Then it creates a copy of the valid transformations and
releases the lock for our update callback to continue updating the list. Locking these lists prevents valid transformations from being overwritten by the update callback to be something that doesn't correspond to the correct timestamp. Then, the loop proceeds to average the translations to obtain a final result, which it publishes to the FCU at "/mavros/mocap/pose."</p>
<p>The current iteration of this algorithm works well due to the fact that we are dealing with only 100 tags. Bottlenecks at scale could include memory usage, as well as slowdowns in numpy's filtering method that we use to find valid transformations. In the future, the system could also be augmented in a number of ways to further increase robustness and will be discussed in a later section.

<h4>The "flyco" Package</h4>
<p>Code specific to the operation of our quadcopter was placed in a ROS package called "flyco", an abbreviation of "Flying Courier". This implementation manifests itself in ROS in the following computation graph:</p>

<div class=row>
  <div class="img-responsive">
    <img class=center-block src="computation_graph.png" alt="">
  </div>
</div>
<br><br>

<p>The primary control mechanism of the system is the main status that flyco_base_node, the main node in our package, publishes to "/flyco/main_status".
<div class=row>
  <div class="img-responsive">
    <img class=center-block src="state_machine.png" alt="">
  </div>
</div>
<br><br>


<h3>Results</h3>
<p>The high level planning component of our project was very successful. The motion capture solution was accurate, the path navigation issued the correct commands, including the payload drop, at the correct locations, and the safety monitor, while on the conservative side, executed the failsafe procedures in the right conditions. Our software architecture allowed us to analyze and test components individually to get the desired system behavior. Our software interface to the quadcopter was also successful, as we were able to take off and land with MAVROS, albeit with lateral drift. Where we fell short was getting the system to fly while using our motion capture system. We had some doubts about the effectiveness of the camera in tracking AR markers through takeoff, but that was ultimately overshadowed by an issue at the firmware level in which the FCU immediately entered a fault state with some unlabeled behavior as soon as it was armed. Despite this, we are confident that the system is close to correct and functional.</p>

<div class=row>
  <div class="img-responsive">
    <img class=center-block src="video" alt="">
  </div>
</div>
<br><br>

<h3>Conclusion</h3>
<p></p>

<h3>Team</h3>


<h3>Reference Material</h3>
<ul>
  <li><a href="http://images01.military.com/media/news/people/army-navy-game1-600x400.jpg">Cadets (Beat Navy!)</a></li>
  <li><a href="https://www.kendo-fik.org/english-page/english-page2/pic/kendo6-7dan-kata.JPG">Kendo practitioners</a></li>
  <li><a href="http://edc.h-cdn.co/assets/15/06/980x490/landscape_nrm_1422911693-01-kitchen-g475.jpg">Kitchen</a></li>
  <li><a href="http://www.santambroeus.com/images/coffee_bar_loews_gallery_02.jpg">Coffee shop</a></li>
</ul>
</body>
</html>

localization improvements
- ransac
- dropout
- refactor for scale
- smart caching based on nearby tags
- upgrade bundle tracking in alvar
